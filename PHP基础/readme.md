## PHP基础总结



这部分总结比较基础，简单归纳一下，写的不多，尚未全部完成

### 一、面向对象基础

1、面向对象关键字说明

- 类：class，是定义面向对象主体的最外层结构，用来包裹主体的数据和功能。类是一类具有共性事务的代表，代表的是事务的共性。
- 对象：object，是某类事务的具体代表，也是实际数据和功能操作的具体单元，也被称之为实例。
- 实例化：new，从一个抽象的概念得到一个符合抽象概念的具体实例的过程。
- 类成员：member，指类class结构中的所有内容，类成员里有三种
  - 方法：method，本质是在类class结构中创建的函数，也称之为`成员方法`
  - 属性：property，本质是在类class结构中创建的变量，也称之为`成员变量`
  - 类常量：const，本质是在类class结构中创建的常量



2、实现创建对象的方式

- 通过class关键字 + 类名+()可以创建类，通过new 类名实例化对象得到类的具体对象，可以new多少个对象都可以。

  

3、类成员

1. PHP类结构中有且仅有三种成员：属性、方法和类常量，其他直接属于类的内容都会报错
2. 类声明需要根据业务来确定类成员的存在和数量
3. 类中属性和方法的访问方式都是通过对象来调用：$对象->属性名/方法名()；**注意属性名不带$符号**
4. 类中定义属性不能直接定义属性名，需要使用修饰限定符修饰（访问修饰限定符中的一种）





4、访问修饰限定符

1. 访问修饰限定符分为三种：public、protected和private，访问权限依次降低（类对成员控制权限依次增加）
2. 访问修饰限定符限定的是成员到底在哪里能被访问，私有和受保护都只能在类内部访问，公有可以在任何地方访问（但都必须是对象去访问）
3. 属性必须写清楚访问修饰限定符，方法可以省去，但是这样做不建议，因为系统默认是public



5、类内部对象

1. 类内部方法内有一个内置对象$this，代表访问该方法的外部对象
2. 类在实例化对象的时候要保证内存中有该类
3. 一个类可以实例化多个对象，每个对象访问成员方法时，$this就代表对应对象



6、面向对象开发注意规范

1. 属性在类中定义的时候，通常不会初始化值
2. 应该尽可能增加类对成员的控制，即使用范围较小的访问修饰限定符优，比如用于给子类继承的类成员就应该用protected修饰而不是用public修饰
3. 属性通常是私有化的，一般是通过设定方法来实现属性的访问和修改，比如setter和getter方法



7、构造方法

1. 构造方法__construct()是一种系统内置的魔术方法，该方法的特性是会在对象实例化之后，对象立即自动调用。构造方法的目的就是为了初始化资源，包含对象属性和其他资源
2. 一旦构造方法定义好之后，且构造方法自带参数，那么就只能使用`new 类名(参数列表)`方式才能正确实例化
3. 构造方法可以当做普通方法由对象调用，但最好不要这样做



8、析构方法

析构方法__destruct()，也是一种类结构中魔术方法，与构造方法一样，但它和构造方法是反过来的，析构方法是用来对象销毁时主动释放资源的

对象销毁一般有如下的情况👇：

- 对象无变量指向（变量指向其他数据）
- 对象被主动销毁（unset销毁对象变量）
- 脚本执行结束（自动释放资源）

- PHP脚本执行结束会释放所有资源，所以一般较少使用析构方法



9、对象传值

对象传值方式是**引用传值**，不论对象如何被赋值给其他变量，始终只有一个对象。这和普通传值的变量不一样



10、范围解析操作符（类常量访问）

1. 类访问成员的方式是使用范围解析操作符“**::**”访问，由类名直接访问：类名::类常量
2. 类本身是通过对同类对象的抽象而形成，所以属性和方法本身都是由对象来访问
3. 类也需要有一些自身的数据和操作，这些就由类来进行访问





11、静态成员

1. 类如果想直接访问数据和操作数据，可以在属性和方法前增加static关键字变成静态属性和静态方法
2. 类通过类名+范围解析操作符+静态成员的方式进行访问
3. 静态成员也受访问修饰限定符的限定，访问权限与普通属性和方法的限制一样
4. 对象可以无条件访问静态方法，而类只能访问不带$this的普通方法，但不建议这样做，这样不符合规范
5. 静态成员是给类访问的，非静态成员是给对象访问的
6. 静态成员的访问效率比非静态成员高，因此有种说法是能用静态的时候就不用非静态



12、self关键字

1. self是一种在类内部用来代替类名的关键字
2. self可以用来在类内部访问静态成员
3. self也可以在类内部用来实例化对象，比如new self()
4. 帮助类名修改时，不用修改任何类的内部结构



13、类的加载

1. 类的使用必须先保证内存中该类存在
2. 可以使用手动加载来确保类的使用安全，但如果要加载多个类的话就很繁琐
3. 自动加载可以使用 __ autoload()函数来实现，也可以使用自定义函数+spl_autoload_register()注册共同实现。现在php7之后  __autoload()函数已经弃用了，所以一般用spl_autoload_register()方法
4. 基本上所有的框架都在使用自动加载机制，而且现在都是使用composer的自动加载功能，最后直接引用一个autoload.php即可



14、对象克隆

1. 对象可以通过克隆来得到新的对象
2. 克隆出来的对象会自动调用类中对应的 __ clone()方法，但前提是定义了 __clone()方法
3. 因为克隆对象是新对象，不会改变原来的对象，如果需要一个和当前对象一致状态的对象，但是又不想改变当前对象的状态，那么就可以通过克隆来实现
4. 可以通过私有化private克隆方法来实现禁止外部对象克隆

注意这里的clone只能算是浅拷贝，也就是说当对象里面存在另一个类的对象成员时，该对象成员并不是一个新的对象成员，而是引用了原来的对象成员。但里面除了对象成员以外的其他成员变量都是新的。



### 二、面向对象高级







###### **面向对象的三大特性**

封装，继承，多态





###### 继承【只能是单继承，不可多继承】

继承是利用extends进行子类和父类的关联，子类对象可以访问父类被继承的成员。而父类对象（如果时直接实例化父类得到的）不可以访问子类成员

继承的注意事项👇：

1. 继承是有限继承，理论上是用来继承父类允许被继承的部分，即使用public或者protected修饰的成员（有限继承指的是有限能用而已）
2. 因为对象的属性是保存在对象内存空间，所以父类的私有属性也会继承
3. 父类私有成员本质不允许被子类访问，但是可以通过父类开放接口实现（一般不会这么操作）
4. 静态成员也可以遵循继承规则
5. 构造方法也可以被继承，因此在实例化子类对象的时候，要考虑到父类构造方法所使用到的参数问题



###### 重写override【php7中要求被重写的方法必须与父类保持参数一致（数量和类型）】

1. 重写override是一种在子类中定义父类同名成员的操作
2. 公有、受保护的属性重写是直接覆盖父类成员，私有属性不会被覆盖；公有、收保护的方法会被重写，但是私有方法不会被重写（私有方法本质没有被继承）
3. 重写的要求
   - 子类控制权不能高于父类控制权
   - 私有方法不能继承，因此不存在重写

4. 静态成员也可以被重写，但是静态属性不会被覆盖（属于类，不属于对象）



###### parent关键字

1. 方法被重写后，访问调用的都是子类方法，如果想要访问父类方法，可以通过在子类方法中使用parent关键字来强制访问父类方法
2. parent不能用于访问父类的属性（静态属性可以）





###### static关键字

1. 静态延迟绑定是指通过static关键字进行类静态成员的访问，是指在被访问时才决定到底使用哪个类
2. 静态延迟绑定对比的是静态绑定self，静态延迟绑定的意义是用来保证访问的静态成员是根据调用类的不同而选择不同的表现



###### final关键字

1. final关键字修饰的类表示无法被继承，final不可修饰属性
2. final关键字还可以修饰方法，表示方法不能子类重写，可以保护内部结构
3. final修饰方法表示不希望方法被修改，可以在一个更高的维度来保证同类事务的共同表现



###### Abstract关键字

1. 使用abstract修饰的类叫做抽象类，不可以被实例化，只能被继承
2. 因为抽象类无法被实例化，因此私有成员在类中没有实质意义（还需要额外提供受保护或者**公有**方法来实现访问）
3. 抽象类的目的是用来规范子类（通常有抽象方法）
4. abstract还可以修饰方法，称之为抽象方法：抽象方法所在的类必须是抽象类，抽象方法不能有方法体；有抽象方法的抽象类被继承时子类要么自身是抽象类，要么实现所有抽象方法



###### trait代码复用【这个是比较重要的，所以总结得比较多】

1、trait是一种类似class结构关键字，trait不能被实例化，可以拥有所有类成员结构，但不能有类常量

2、trait是用来实现代码复用的，为其他类提供公共代码（方法），其他类如果使用trait用use关键字引入

3、在类中use具体trait就相当于将trait内的所有代码在类中写了一遍

4、一个类可使用多个trait，但是注意同名问题，最好别同名，处理如下👇：

- 同名方法可以使用insteadof来实现替代：一个trait中的同名方法替代另外一个，类就访问替代的那个
- 同名方法可以在被替代之后使用as制作方法别名：类就可以拥有两个方法

5、类中在引入trait后，要注意与trait中的同名成员问题

- 同名属性：不允许的（除非同名同值就可以）
- 同名方法：允许的，类中的方法会覆盖trait中的方法

6、如果类在使用trait的同时也继承了其他类，那么trait中出现的同名方法会覆盖基类的同名方

7、类在使用trait时可以修改trait方法的控制级别：更严或者更宽松都可以

- 直接修改：[trait名::]方法名 as 访问修饰限定符;（会让引入类只有一个方法名，这种应用较多）
- 通过别名：[trait名::]方法名 as 访问修饰限定符 别名;（会让引入类有两个方法：一个是trait本身方法（不会被修改），一个是别名（最终修改的权限）

8、trait中可以使用抽象方法，那么使用该trait的类就必须本身为抽象类或者将抽象方法实现

9、**还有比较容易忽视的trait同名方法出现在子类，父类时👇：**

1. 继承覆盖问题：如果类中在使用trait的同时，也是继承自父类，而trait中与父类中有同名方法，那么trait中将覆盖父类同名方法
2. 在trait和父类同时存在同名方法下，如果要访问父类方法，可以在trait同名方法中使用parent关键字访问父类同名方法
3. 如果子类、trait和父类中同时存在同名方法：那么子类访问自身的，使用parent访问父类的，trait的被覆盖无法被访问到（除非别名）

 **trait的使用场景一般为作为公共代码，并且这段公共代码在很多地方会被使用到**



###### interface接口

1. 接口不能实例化，类可以实现接口，目的是为了规范一些类的必要的行为
2. 接口成员只有两种：接口常量和公有抽象方法（没有方法体）；类实现接口的时候，必须实现接口中所有的抽象方法（或者抽象类实现），而且实现的类不能重新类常量和权限更小（比如private和protected）
3. 一个接口可以继承多个接口



##### 重载

###### 1.属性重载

当对象访问不存在的或者权限不够的属性或者方法时，自动触发的魔术方法让代码不出错（容错处理）

属性重载魔术方法👇

- __get(属性名)：访问不存在或者权限不够的属性时触发
- __set(属性名,属性值)：设置不存在或者权限不够的属性时触发
- __isset(属性名)：判定不存在或者权限不够的属性时触发
- __unset(属性名)：删除不存在或者权限不够的属性时触发

###### 2.方法重载

方法重载魔术方法👇

- __call(方法名,方法参数列表)：调用不存在或者权限不够的方法时触发
- __callStatic(方法名,方法参数列表)：调用不存在或者权限不够的静态方法时触发



###### Iterator迭代器

Iterator迭代器是专门针对有遍历对象控制的类的而存在的，常用的有迭代器的有array，继承Iterator接口的类，和spl里面的那些数据结构

- Iterator迭代器内置了5个抽象方法，实现迭代器的类必须实现5个抽象方法，注意：【**实现了Iterator迭代器接口的类的对象在进行foreach时，不会按照foreach原来的机制处理，而是调用迭代器的5个方法**】
- foreach本身的执行步骤
  - ① 初始化目标：将对象指针指向第一个属性（执行一次）
  - ② 判定指针是否有效：判定当前指针指向的元素是否存在，存在下一步，不存在终止（N+1次执行）
  - ③ 取出当期指针元素下标（属性名）：将当前属性的名字取出来存储到变量（N次执行）
  - ④ 取出当前指针元素值（属性值）：将当前属性的值取出来存储到变量（N次执行）
  - ⑤ 将指针指向下一个：将取出元素后的指针指向下一个属性（N次执行）



###### yield+generator生成器

yield关键字代表暂停代码继续向下执行：直到yield代码被使用（循环遍历）；生成器对象遍历：使用yield后，函数就会返回一个Generator的对象，此时就可以针对对象进行遍历（需要函数对yield进行包装：函数才有返回值）

下面举个很简单的例子👇

```php
function getArr(){
    for($i = 0;$i < 10000;$i++){
        yield $i;
    }
}
$g = getArr();
foreach($g as $v){
    echo $v . ' ';
}
```

生成器的目的是利用yield关键字实现循环内部的暂停，而直到yield被使用使用循环才会继续执行，从而节省通过循环产生一个大数组的过程，最终实现内存优化



## 三、命名空间















































